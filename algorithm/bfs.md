# 幅優先探索 (Breadth-First Search)

- [幅優先探索 (Breadth-First Search)](#幅優先探索-breadth-first-search)
  - [幅優先探索とは](#幅優先探索とは)
  - [扱うデータ構造](#扱うデータ構造)
  - [処理イメージ](#処理イメージ)
  - [計算量](#計算量)
    - [時間計算量](#時間計算量)
    - [空間計算量](#空間計算量)
  - [深さ優先探索と幅優先探索の比較](#深さ優先探索と幅優先探索の比較)
  - [コード](#コード)
    - [各頂点の最短ステップを取得するプログラム](#各頂点の最短ステップを取得するプログラム)
  - [参考資料](#参考資料)

## 幅優先探索とは

> アルゴリズムは根ノードで始まり隣接した全てのノードを探索する。それからこれらの最も近いノードのそれぞれに対して同様のことを繰り返して探索対象ノードをみつける。

[Wikipedia - 幅優先探索](https://ja.wikipedia.org/wiki/%E5%B9%85%E5%84%AA%E5%85%88%E6%8E%A2%E7%B4%A2)

## 扱うデータ構造

- グラフのデータ
  - 「各頂点の隣接リストを格納した２次元配列」のデータ構造とした扱う

**イメージ**

```python
graph = [[1, 2, 6], [5, 7], [7], [3, 6]]
```

## 処理イメージ

いったん保留にした頂点を一通りすべて読み終えてから、より深いところにある頂点へ進む。

1. 初期値を設定
   1. 「始点とした頂点」 を queue に登録する
   2. 「始点とした頂点」に到達済みフラグをつける
2. queue より `頂点` を１つ取得する
3. 上の２で取得した頂点より隣接リストを取得する
   1. 隣接リスト内の頂点１つを queue に登録する
   2. queue に登録した頂点に到達済みフラグをつける
   3. 隣接リストが空になるまで、１を繰りかえす
4. queue が空になるまで２に戻る

## 計算量

### 時間計算量

最悪の場合、幅優先探索は全ての経路を考慮に入れる必要があるので、幅優先探索の時間計算量は `O(|E|)` である。ここで `|E|` はグラフ内の辺の数である。

### 空間計算量

見つかったノードを全て記録する必要があるので、幅優先探索の空間計算量は `O(|V|)` となる。ここで `|V|` はグラフ内のノードの数である。

## 深さ優先探索と幅優先探索の比較

|   アルゴリズム名    | 利用するケース                                          |
| :-----------------: | ------------------------------------------------------- |
| DFS（深さ優先探索） | 辞書順最小な経路から順番に探索したい<br>メモ化再帰の DP |
|  BFS（幅優先探索）  | 最短経路問題（迷路）<br>                                |

## コード

### 各頂点の最短ステップを取得するプログラム

```python
from collections import deque

# 頂点が9つの無向グラフ
GRAPH = [
    [1, 4, 2], [0, 3, 4, 8], [0, 5],
    [1, 8, 7], [0, 1, 8], [2, 6, 8],
    [5, 7], [3, 6], [1, 3, 4, 5]
]

que: deque = deque([])                            # 「次に読みに行く頂点」を一時保管するためのキュー
distinct_list = [0 for _ in range(len(GRAPH))]    # 各頂点が何ステップで到達できるかを記録するリスト
vector_list = [False for _ in range(len(GRAPH))]  # すでに到達した頂点であるかを管理するリスト

# 初期条件（GRAPH[0]が始点とする）の設定
que.append(0)
vector_list[0] = True

while que:
    vertex = que.popleft()
    for i in GRAPH[vertex]:                           # 隣接する頂点を順に見に行く
        if vector_list[i]:                            # 既に到達済みの頂点の場合はスキップ
            continue
        distinct_list[i] = distinct_list[vertex] + 1  # ステップ数を記録
        vector_list[i] = True                         # 到達済みの記録
        que.append(i)                                 # キューに登録

print(distinct_list)
# [0, 1, 1, 2, 1, 2, 3, 3, 2]
```

## 参考資料

- [アルゴ式 幅優先探索 (BFS) を徹底解説](https://algo-method.com/descriptions/114#h2-24)
- [Qiita BFS (幅優先探索) 超入門！ 〜 キューを鮮やかに使いこなす 〜](https://qiita.com/drken/items/996d80bcae64649a6580#1-5-dfs-%E3%81%A8-bfs-%E3%81%A8%E3%81%AE%E6%AF%94%E8%BC%83)
- [【ゆっくり解説】BFS(幅優先探索)解説 ABC138 D【競技プログラミング】](https://www.youtube.com/watch?v=WyJvs9hL9Yc&t=65s)
- [【ゆっくり実況】幅優先探索(BFS)めっちゃていねいに説明、AtCoder209D【Python プログラミング入門/ゆっくり解説】](https://www.youtube.com/watch?v=4sKzFGWoNYQ)
