# 深さ優先探索 (Depth-First Search)

- [深さ優先探索 (Depth-First Search)](#深さ優先探索-depth-first-search)
  - [深さ優先探索とは](#深さ優先探索とは)
  - [処理イメージ](#処理イメージ)
  - [計算量](#計算量)
    - [時間計算量](#時間計算量)
    - [空間計算量](#空間計算量)
  - [基本的なコード](#基本的なコード)
  - [参考コード](#参考コード)
    - [`根付き木` で、各頂点の `深さ` を取得するプログラム](#根付き木-で各頂点の-深さ-を取得するプログラム)
    - [`根付き木` で、各頂点の `子孫` を取得するプログラム](#根付き木-で各頂点の-子孫-を取得するプログラム)

## 深さ優先探索とは

> 深さ優先探索（ふかさゆうせんたんさく、英: depth-first search, DFS、バックトラック法ともいう）は、木やグラフを探索するためのアルゴリズムである。アルゴリズムは根から(グラフの場合はどのノードを根にするか決定する)始まり、バックトラックするまで可能な限り探索を行う。

[Wikipedia - 深さ優先探索](https://ja.wikipedia.org/wiki/%E6%B7%B1%E3%81%95%E5%84%AA%E5%85%88%E6%8E%A2%E7%B4%A2)

再帰関数を利用することで、各頂点をたどることができる。

## 処理イメージ

たどれる頂点をとにかく突き進む

1. `根` の `頂点` をみて、`子供` を持っている場合には、とにかく、「その子供の頂点」に進んでいく
   1. `子供` が複数いる場合には、どちらか一方へ、まず進んでいく
   2. つまり、一方の `子供` の `頂点` は置き去りにされる
2. 「その子供の頂点」がさらに `子供` を持っている場合には、「その子供の頂点」に進んでいく
3. 「その子供の頂点」が `子供` を持っていない場合、一旦戻って、「置き去りにされた子供の頂点」を進んでいく

## 計算量

### 時間計算量

最悪のケースではノード数とたどる辺の数の合計に比例する。

### 空間計算量

深さ優先探索の空間計算量は幅優先探索の空間計算量より最悪のケースでは同じだが一般的なケースではずっと小さい。また、探索の種類によっては、分岐を選択するためのヒューリスティックな方法にも向いている。

ヒューリスティックな方法とは、必ずしも正しい答えを導けるとは限らないが、ある程度のレベルで正解に近い解を得ることができる方法である。発見的手法では、答えの精度が保証されない代わりに、解答に至るまでの時間が短いという特徴がある。

## 基本的なコード

```python
import sys
sys.setrecursionlimit(10 ** 6)

# 二分木（頂点の数：9, 深さ：3）
TREE = [
    [1, 2],
    [3, 4], [5, 6],
    [7, 8], [None, 9], [None, None], [None, None],
    [None, None], [None, None], [None, None]
]

vertex_order = []
def recursive(v: int):
    if v is not None:
        # vertex_order.append(v) # 「行きがけ順」で表示される
        recursive(TREE[v][0])
        # vertex_order.append(v) # 「通りがけ順」で表示される
        recursive(TREE[v][1])
        # vertex_order.append(v)  # 「帰りがけ順」で表示される
    return vertex_order

recursive(0)
print(" => ".join(list(map(str, vertex_order))))
# 「行きがけ順」0 => 1 => 3 => 7 => 8 => 4 => 9 => 2 => 5 => 6
# 「通りがけ順」7 => 3 => 8 => 1 => 4 => 9 => 0 => 5 => 2 => 6
# 「帰りがけ順」7 => 8 => 3 => 9 => 4 => 1 => 5 => 6 => 2 => 0
```

`深さ優先探索` は、下記３つの巡回方法がある

|       巡回方法       | 説明                                          |
| :------------------: | --------------------------------------------- |
| 行きがけ順（先行順） | `根` => `左の子供` => `右の子供` の順に調べる |
| 通りがけ順（中間順） | `左の子供` => `根` => `右の子供` の順に調べる |
| 帰りがけ順（後行順） | `左の子供` => `右の子供` => `根` の順に調べる |

## 参考コード

### `根付き木` で、各頂点の `深さ` を取得するプログラム

- 「各頂点の深さ」とは、「親の頂点の深さに１を加算したもの」である
- そのため
  - 各頂点の深さを格納するリストを用意
  - 行きがけ順で巡回して、親の頂点の深さを参照しながら、各頂点の深さの値を埋めていけば良い

```python
import sys
sys.setrecursionlimit(10 ** 6)

# 二分木（頂点の数：9, 深さ：3）
TREE = [
    [1, 2],
    [3, 4], [5, 6],
    [7, 8], [None, 9], [None, None], [None, None],
    [None, None], [None, None], [None, None]
]

# 各頂点の深さを格納するリスト。初期値で0を入れておく。
depth_list = [0 for _ in range(len(TREE))]


def recursive(vertex: int, parent: int):
    if vertex == 0:  # 頂点が根の場合は深さ0を代入
        depth_list[0] = 0
    else:            # それ以外の場合、親の深さに1を加算する
        depth_list[vertex] = depth_list[parent] + 1

    # 隣接リストをたどる
    for i in TREE[vertex]:
        if i is not None:
            recursive(i, vertex)


recursive(0, -1)
print(depth_list)
# [0, 1, 1, 2, 2, 2, 2, 3, 3, 3]
print(max(depth_list))
# 3
```

### `根付き木` で、各頂点の `子孫` を取得するプログラム

- 「各頂点の子孫」とは
  - 「その頂点を根とした部分木の頂点総数」より「１」を引いたものである
  - 「子供となる頂点の子孫総数」である
- そのため
  - 各頂点ごとに、「部分木とした場合の頂点総数」を格納するリストを用意
  - 帰りがけ順で巡回して、子供となる頂点の「頂点総数」を参照しながら、各頂点での値を埋めていけば良い

```python
import sys
sys.setrecursionlimit(10 ** 6)

# 二分木（頂点の数：9, 深さ：3）
TREE = [
    [1, 2],
    [3, 4], [5, 6],
    [7, 8], [None, 9], [None, None], [None, None],
    [None, None], [None, None], [None, None]
]

# 各頂点ごとの、「部分木とした場合の頂点総数」を格納するリスト
vertex_count_list = [0 for _ in range(len(TREE))]


def recursive(vertex):
    for i in TREE[vertex]:
        if i is not None:
            recursive(i)

    # 帰りがけ順なので、再帰が途切れたタイミングで処理
    vertex_count_list[vertex] = 1   # 自分自身をカウントする
    for j in TREE[vertex]:
        if j is not None:
            vertex_count_list[vertex] += vertex_count_list[j]


recursive(0)
print([i-1 for i in vertex_count_list])     # 子孫を求めるので、頂点総数より１を引く
# [9, 5, 2, 2, 1, 0, 0, 0, 0, 0]
for i, v in enumerate(vertex_count_list):
    print(f"頂点：{i:2}, 子孫:{v-1:2}")
    # 頂点： 0, 子孫: 9
    # 頂点： 1, 子孫: 5
    # 頂点： 2, 子孫: 2
    # 頂点： 3, 子孫: 2
    # 頂点： 4, 子孫: 1
    # 頂点： 5, 子孫: 0
    # 頂点： 6, 子孫: 0
    # 頂点： 7, 子孫: 0
    # 頂点： 8, 子孫: 0
    # 頂点： 9, 子孫: 0
```
