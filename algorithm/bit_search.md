# bit search（bit 全探索）

## bit 全探索とは

- ありえる組み合わせをすべて試す全探索の一種
- ２択によって決められる N 個の状態のすべての組み合わせを調べる
- イメージとしては
  - 「使う／使わない」を全探索する
  - 「選ぶ／選ばない」を全探索する

[こわくない bit 全探索 1 入門編: bit 全探索ってなに？【競プロ解説】 | Qiita](https://qiita.com/u2dayo/items/68e35815659b1041c3c2)

[【ゆっくり解説】bit 全探索 ABC182 C【競技プログラミング】 | Youtube](https://www.youtube.com/watch?v=umfbbrElhaM)

## 典型問題（部分和問題）

長さが `N` の数列（A とする） `{1, 2, ..., N}` がある。

その数列より複数の値を選択し、その合計（W とする）が `10` となるパターンは何種類あるか。

## 計算量

### 時間計算量

O(2^N)

## 実装方法

直積集合を利用する方法と、ビット演算を利用する方法がある。

### 直積集合を利用して実装

[itertools.product](https://docs.python.org/ja/3/library/itertools.html#itertools.product) を利用する。

```python
from itertools import product

N = 5                   # 数列内の値の数
A = [1, 2, 3, 4, 5]     # 数列
W = 10                  # 求める合計値
count = 0               # 合致するパターン数

# 数列内の値の数だけ、真偽値を利用した直積集合を用意する
# 下記のようなパターンが作成される
#  (True, True, True, True, True)
#  (True, True, True, True, False)
#  ...
#  (False, False, False, False, False)
for pattern in product((True, False), repeat=N):
    sum = 0
    for i in range(N):
        # Trueの時に、数列Aより合算値を求める
        if pattern[i]:
            sum += A[i]
    # 合算値を求める値と比較する
    if sum == W:
        count += 1

print(count)
# 3
# 以下のパターンが合致する
#  (True, True, True, True, False)
#  (True, False, False, True, True)
#  (False, True, True, False, True)
```

[こわくない bit 全探索 2 基本編 1: 簡単な例題で bit 全探索をやってみよう！【競プロ解説】 | Qiita](https://qiita.com/u2dayo/items/8c1601a61841540b4947)

### ビット AND 演算を利用して実装

`ビットシフト` と `ビットAND演算` を利用する。

```python
N = 5  # 数列内の値の数
A = [1, 2, 3, 4, 5]  # 数列
W = 10  # 求める合計値
count = 0


for bit in range(1 << N):  # range(1 << 5) は、range(2 ** 5) と同義で、32パターンを処理することになる
    sum = 0
    for i in range(N):
        # 以下のビットAND演算を求める
        # - bit => [0, 1, 10, 11, ...]
        # - 1 を i 回左シフトした数 => [0, 10, 100, 1000, 10000]
        if bit & (1 << i) != 0:
            sum += A[i]
        # 比較処理内容
        print(
            {
                f"bin({bit})": bin(bit),
                f"(1 << {i})": bin(1 << i),
                f"bin({bit} & (1 << {i}))": f"{bin(bit & (1 << i))} => {bool(bit & (1 << i))})",
            }
        )
        # {'bin(0)': '0b0', '(1 << 0)': '0b1', 'bin(0 & (1 << 0))': '0b0 => False)'}
        # {'bin(0)': '0b0', '(1 << 1)': '0b10', 'bin(0 & (1 << 1))': '0b0 => False)'}
        # {'bin(0)': '0b0', '(1 << 2)': '0b100', 'bin(0 & (1 << 2))': '0b0 => False)'}
        # {'bin(0)': '0b0', '(1 << 3)': '0b1000', 'bin(0 & (1 << 3))': '0b0 => False)'}
        # {'bin(0)': '0b0', '(1 << 4)': '0b10000', 'bin(0 & (1 << 4))': '0b0 => False)'}
        # {'bin(1)': '0b1', '(1 << 0)': '0b1', 'bin(1 & (1 << 0))': '0b1 => True)'}
        # {'bin(1)': '0b1', '(1 << 1)': '0b10', 'bin(1 & (1 << 1))': '0b0 => False)'}
        # {'bin(1)': '0b1', '(1 << 2)': '0b100', 'bin(1 & (1 << 2))': '0b0 => False)'}
        # {'bin(1)': '0b1', '(1 << 3)': '0b1000', 'bin(1 & (1 << 3))': '0b0 => False)'}
        # {'bin(1)': '0b1', '(1 << 4)': '0b10000', 'bin(1 & (1 << 4))': '0b0 => False)'}
        # {'bin(2)': '0b10', '(1 << 0)': '0b1', 'bin(2 & (1 << 0))': '0b0 => False)'}
        # {'bin(2)': '0b10', '(1 << 1)': '0b10', 'bin(2 & (1 << 1))': '0b10 => True)'}
        # {'bin(2)': '0b10', '(1 << 2)': '0b100', 'bin(2 & (1 << 2))': '0b0 => False)'}
        # {'bin(2)': '0b10', '(1 << 3)': '0b1000', 'bin(2 & (1 << 3))': '0b0 => False)'}
        # {'bin(2)': '0b10', '(1 << 4)': '0b10000', 'bin(2 & (1 << 4))': '0b0 => False)'}
        # ...
        # {'bin(13)': '0b1101', '(1 << 0)': '0b1', 'bin(13 & (1 << 0))': '0b1 => True)'}
        # {'bin(13)': '0b1101', '(1 << 1)': '0b10', 'bin(13 & (1 << 1))': '0b0 => False)'}
        # {'bin(13)': '0b1101', '(1 << 2)': '0b100', 'bin(13 & (1 << 2))': '0b100 => True)'}
        # {'bin(13)': '0b1101', '(1 << 3)': '0b1000', 'bin(13 & (1 << 3))': '0b1000 => True)'}
        # {'bin(13)': '0b1101', '(1 << 4)': '0b10000', 'bin(13 & (1 << 4))': '0b0 => False)'}
        # {'bin(14)': '0b1110', '(1 << 0)': '0b1', 'bin(14 & (1 << 0))': '0b0 => False)'}
        # {'bin(14)': '0b1110', '(1 << 1)': '0b10', 'bin(14 & (1 << 1))': '0b10 => True)'}
        # {'bin(14)': '0b1110', '(1 << 2)': '0b100', 'bin(14 & (1 << 2))': '0b100 => True)'}
        # {'bin(14)': '0b1110', '(1 << 3)': '0b1000', 'bin(14 & (1 << 3))': '0b1000 => True)'}
        # {'bin(14)': '0b1110', '(1 << 4)': '0b10000', 'bin(14 & (1 << 4))': '0b0 => False)'}
        # {'bin(15)': '0b1111', '(1 << 0)': '0b1', 'bin(15 & (1 << 0))': '0b1 => True)'}
        # {'bin(15)': '0b1111', '(1 << 1)': '0b10', 'bin(15 & (1 << 1))': '0b10 => True)'}
        # {'bin(15)': '0b1111', '(1 << 2)': '0b100', 'bin(15 & (1 << 2))': '0b100 => True)'}
        # {'bin(15)': '0b1111', '(1 << 3)': '0b1000', 'bin(15 & (1 << 3))': '0b1000 => True)'}
        # {'bin(15)': '0b1111', '(1 << 4)': '0b10000', 'bin(15 & (1 << 4))': '0b0 => False)'}
        # ...
        # {'bin(30)': '0b11110', '(1 << 0)': '0b1', 'bin(30 & (1 << 0))': '0b0 => False)'}
        # {'bin(30)': '0b11110', '(1 << 1)': '0b10', 'bin(30 & (1 << 1))': '0b10 => True)'}
        # {'bin(30)': '0b11110', '(1 << 2)': '0b100', 'bin(30 & (1 << 2))': '0b100 => True)'}
        # {'bin(30)': '0b11110', '(1 << 3)': '0b1000', 'bin(30 & (1 << 3))': '0b1000 => True)'}
        # {'bin(30)': '0b11110', '(1 << 4)': '0b10000', 'bin(30 & (1 << 4))': '0b10000 => True)'}
        # {'bin(31)': '0b11111', '(1 << 0)': '0b1', 'bin(31 & (1 << 0))': '0b1 => True)'}
        # {'bin(31)': '0b11111', '(1 << 1)': '0b10', 'bin(31 & (1 << 1))': '0b10 => True)'}
        # {'bin(31)': '0b11111', '(1 << 2)': '0b100', 'bin(31 & (1 << 2))': '0b100 => True)'}
        # {'bin(31)': '0b11111', '(1 << 3)': '0b1000', 'bin(31 & (1 << 3))': '0b1000 => True)'}
        # {'bin(31)': '0b11111', '(1 << 4)': '0b10000', 'bin(31 & (1 << 4))': '0b10000 => True)'}
    if sum == W:
        count += 1

print(count)
# 3
# 以下のパターンが合致する
#  0b1111
#  0b10110
#  0b11001
```

[こわくない bit 全探索 3 基本編 2: 2 進法を使って実装してみよう！【競プロ解説】 | Qiita](https://qiita.com/u2dayo/items/e321c66aa43e3a9b1b31)

golang の場合。

```golang
package main

import "fmt"

func main() {
	N := 5
	A := []int{1, 2, 3, 4, 5}
	W := 10

	count := 0
	for bit := 0; bit < (1 << N); bit++ {
		sum := 0
		for i := 0; i < N; i++ {
			if bit&(1<<i) != 0 {
				sum += A[i]
			}
		}
		if sum == W {
			count++
		}
	}
	fmt.Println(count)
}
```
