# 二次元座標（迷路とか）上で、頂点を移動させる方法

## 考え方

頂点を移動するパターンを用意して、現在の座標に加減すればよい。

## イメージ

`x = 2, y = 2` という頂点より、移動するパターンは以下の４つとなる。

1. x = 3, y = 2
2. x = 2, y = 3
3. x = 1, y = 2
4. x = 2, y = 1

つまり、移動するパターンのベクトルは、以下の４つとなる。

1. [+1, 0]
2. [0, +1]
3. [-1, 0]
4. [0, -1]

## コードで表現

Python では、組み込み関数の `zip()` を利用して、以下のコードで表現できる。

```python
# ベクトルの定義
dxs = [1, 0, -1, 0]
dys = [0, 1, 0, -1]

tmp = zip(dxs, dys)   # 移動可能なベクトルを網羅するパターンを作成
print(list(tmp))      # 組み込み関数 zip() は、iterable な tuple を返すので、list 型にして表示
# [(1, 0), (0, 1), (-1, 0), (0, -1)] ※ 「右に移動」「上に移動」「左に移動」「下に移動」のパターンができる

# 始点の定義
x, y = 2, 2

# 移動するパターンの表示
count = 0
for dx, dy in zip(dxs, dys):
    print(f"-- count: {count}--")
    print(f"dx: {dx}, dy: {dy}")

    # 始点に加算
    nx = x + dx
    ny = y + dy
    print(f"ns: {nx}, ny: {ny}")

    count += 1

"""
出力結果
-- count: 0--
dx: 1, dy: 0
ns: 3, ny: 2
-- count: 1--
dx: 0, dy: 1
ns: 2, ny: 3
-- count: 2--
dx: -1, dy: 0
ns: 1, ny: 2
-- count: 3--
dx: 0, dy: -1
ns: 2, ny: 1
"""
```
